%%
%% This is file `sample-sigconf.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf')
%%
%% IMPORTANT NOTICE:
%%
%% For the copyright see the source file.
%%
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf.tex.
%%
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%%
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigplan,screen,review, nonacm]{acmart}

\usepackage{color}
\usepackage{fancyvrb}

\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
% \setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\usepackage{multicol}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi


%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2021}
\acmYear{2021}
% \acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Optics for generic declarative server APIs}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Andre Videla}
\affiliation{%
  \institution{University of Strathclyde}
}
%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%


%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle
\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

A considerable amount of engineering effort is
continuously deployed to implement and manage servers, and not enough
research has been done to improve the experience of creating and maintaining
servers. Traditionally, they are implemented by parsing a request
and performing the action that corresponds to the functionality advertised
by the documentation. We make progress in
this area by providing a new \emph{purely declarative} library for
servers that avoids errors associated with
the tight coupling that emerges from imperative solutions. We use Idris2\cite{idris2},
dependent types, and lenses to achieve
this goal and demonstrate how to implement and extend server APIs with
as little code as possible.

\hypertarget{declarative-frameworks}{%
  \section{Declarative frameworks}\label{declarative-frameworks}}

A common tool for the modern software engineer working on a server is
a framework to define and document its API, we call those
\emph{delcarative frameworks}. Ther differ
from the traditional approach which consists in implementing the server
as a program that parses requests and sends responses. A declarative framework
only \emph{describes} incoming and outgoing requests, with no
bearing on the implementation.
Contemporary declarative frameworks for servers include \emph{Swagger}\cite{swagger}, a very
popular choice in the industry, and Haskell's \emph{Servant}\cite{servant}, the state of the
art in declarative server libraries. Swagger allows the programmer to define
APIs in an external program, and then generates documentation and source code for the API. Servant
takes a more embedded approach by defining the server's APIs as a \emph{type} in Haskell and then
requesting the programmer to provide functions that implement the given API.
We take a similar approach to Servant but make use of dependent types to unlock
new abstractions through the relationship between endpoints and lenses.

\hypertarget{server-endpoints-as-resources}{%
\section{Server endpoints as
resources}\label{server-endpoints-as-resources}}

A web server can be characterised by its \emph{endpoints}, each endpoint
describes what kind of input an HTTP\cite{http} request provides and what kind of
response is sent from the server. For our purposes, we are going to
identify two operations: \emph{querying} the state of the server, and \emph{updating}
the state of the server. We use HTTP \emph{verbs} to
declare what kind of operation the request is performing, typically a
\texttt{GET} request would query the state, while a \texttt{POST}
request would update the state - while carrying data through a
 \emph{request body}.

Now, imagine the endpoint returns a list of todo
items for a given user: \texttt{GET\ todo/:user} (\texttt{:user} is syntax for a url capture).
Using our library we can define this
endpoint like so :
\texttt{\StringTok{"todo"}\ \OperatorTok{/}\ \OtherTok{Cap}\ \DataTypeTok{User}\ \OperatorTok{/}\
\OtherTok{Returns}\ (\OtherTok{List}\ \DataTypeTok{Todo})\ \DataTypeTok{Get}}. In this
one line we've defined the url path (\texttt{\StringTok{"todo"}}),
the url capture (\texttt{\OtherTok{Cap}\ \DataTypeTok{User}} for \texttt{:user}),
which kind of request we're expecting (\texttt{GET} or \texttt{POST}), and what kind of
response the client expects (a \texttt{\OtherTok{List}\ \DataTypeTok{Todo}}). We require the
user to provide an implementation for this endpoint. The client will see this endpoint as a function
\texttt{\DataTypeTok{User}\ \KeywordTok{-\textgreater{}}\ \OtherTok{List}\ \DataTypeTok{Todo}}.
But attempting to implement
this function as the server will result in unavoidable failure, as there is no way to
\emph{lookup} which \texttt{\OtherTok{List}\ \DataTypeTok{Todo}} to return.
The intent of the server is to provide a view of its internal state, in our particular case, the state
is a dictionary storing \texttt{\DataTypeTok{User}}s as keys
and \texttt{\OtherTok{List}\ \DataTypeTok{Todo}} as values. In Idris this type is called
\texttt{\OtherTok{Map}\ \DataTypeTok{User}\ (\OtherTok{List}\ \DataTypeTok{Todo})}.
Implementing our server while using its state amounts to implementing the function with the
following type signature : \texttt{\DataTypeTok{User}\ \KeywordTok{-\textgreater{}}\ \OtherTok{Map}\ \DataTypeTok{User}\ (\OtherTok{List}\ \DataTypeTok{Todo})\ \KeywordTok{-\textgreater{}}\ \OtherTok{List}\ \DataTypeTok{Todo}}.

In addition to queries, servers also perform state update operations. We
represent these with a \texttt{POST} request which carries a request
\emph{body}. For example, an endpoint that adds a new todo item
for a given user looks like this
\texttt{\StringTok{"todo"}\ \OperatorTok{/}\ \OtherTok{Cap}\ \DataTypeTok{User}\ \OperatorTok{/}\ \OtherTok{Returns}\ (\OtherTok{List}\ \DataTypeTok{Todo})\ (\OtherTok{Post}\ \DataTypeTok{Todo})}.
Again we can deduce the corresponding function that implements this
endpoint using our state:
\texttt{\DataTypeTok{User}\ \KeywordTok{-\textgreater{}}\ \DataTypeTok{Todo}\ \KeywordTok{-\textgreater{}}\ \OtherTok{Map}\ \DataTypeTok{User}\ (\OtherTok{List}\ \DataTypeTok{Todo})\ \KeywordTok{-\textgreater{}}\ (\OtherTok{List}\ \DataTypeTok{Todo},\ \OtherTok{Map}\ \DataTypeTok{User}\ (\OtherTok{List}\ \DataTypeTok{Todo}))}

The new state is paired up with the response of the server in order for
the library to update its internal state. It is
extremely common for servers to provide an API that allows both
\emph{querying} and \emph{updating} the state. In our library we call
those \emph{resources} and we can refactor the previous two endpoints into a
single one:
\texttt{\StringTok{"todo"}\ \OperatorTok{/}\ \OtherTok{Cap}\ \DataTypeTok{User}\ \OperatorTok{/}\ \OtherTok{Resource}\ \DataTypeTok{Todo}\ (\OtherTok{List}\ \DataTypeTok{Todo})}.

To understand how a \texttt{Resource} is implemented, it is informative to
look at the type that describes APIs:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Path} : \DataTypeTok{Type} \KeywordTok{where}
  \FunctionTok{Ends} : (returnType : \DataTypeTok{Type}) \KeywordTok{->}
         \OtherTok{Show} returnType \KeywordTok{=>}
         (v : \DataTypeTok{Verb}) \KeywordTok{->} \DataTypeTok{Path}
  \FunctionTok{Plain} : \DataTypeTok{String} \KeywordTok{->} (ps : \DataTypeTok{Path}) \KeywordTok{->} \DataTypeTok{Path}
  \FunctionTok{Capture} : (name : \DataTypeTok{String}) \KeywordTok{->}
            (t : \DataTypeTok{Type}) \KeywordTok{->} \OtherTok{HasParser} t \KeywordTok{=>}
            (ps : \DataTypeTok{Path}) \KeywordTok{->} \DataTypeTok{Path}
  \FunctionTok{Split} : \OtherTok{List} \DataTypeTok{Path} \KeywordTok{->} \DataTypeTok{Path}
\end{Highlighting}
\end{Shaded}

A \texttt{\DataTypeTok{Path}} is a tree of path components which are either
\texttt{\DataTypeTok{Type}}s or \texttt{\DataTypeTok{String}}s,
they can also embed a list of \texttt{\DataTypeTok{Path}}s which describes endpoints with a
common prefix.

Given this definition, a \texttt{\OtherTok{Resource}} is nothing but an alias for
\texttt{\FunctionTok{Split} [\FunctionTok{Ends} ret \DataTypeTok{Get}, \FunctionTok{Ends} ret (\OtherTok{Post} val)]}
it reprents two endpoints that terminate with a \texttt{POST} and
\texttt{GET} request.


\hypertarget{resources-as-lenses}{%
\section{Resources as lenses}\label{resources-as-lenses}}

In our previous example, we defined our server as a pair of two
endpoints that query and update the same resource. If we place the two
generated signatures side by side we recognise a well-known pattern:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{GET}  \OperatorTok{:} \DataTypeTok{User} \KeywordTok{{-}\textgreater{}} \OtherTok{Map} \DataTypeTok{User}\NormalTok{ (}\OtherTok{List} \DataTypeTok{Todo}\NormalTok{) }\KeywordTok{{-}\textgreater{}} \OtherTok{List} \DataTypeTok{Todo}
\FunctionTok{POST} \OperatorTok{:} \DataTypeTok{User} \KeywordTok{{-}\textgreater{}} \DataTypeTok{Todo} \KeywordTok{{-}\textgreater{}} \OtherTok{Map} \DataTypeTok{User}\NormalTok{ (}\OtherTok{List} \DataTypeTok{Todo}\NormalTok{) }\KeywordTok{{-}\textgreater{}}
\NormalTok{            (}\OtherTok{List} \DataTypeTok{Todo}\NormalTok{, }\OtherTok{Map} \DataTypeTok{User}\NormalTok{ (}\OtherTok{List} \DataTypeTok{Todo}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

If we abstract over the state and pack up
our arguments in pairs we obtain the less verbose signature:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{GET}  \OperatorTok{:} \NormalTok{(args, state) }\KeywordTok{{-}\textgreater{}}\NormalTok{ resource}
\FunctionTok{POST} \OperatorTok{:} \NormalTok{(args, state) }\KeywordTok{{-}\textgreater{}}\NormalTok{ newValue }\KeywordTok{{-}\textgreater{}}
            \NormalTok{(newResource, state)}
\end{Highlighting}
\end{Shaded}

Which resembles the traditional definition of
lenses\cite{profunctors}! As a reminder, a lens is a pair of functions parameterised over
the types \texttt{a}, \texttt{b}, \texttt{s}, \texttt{t}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{get }\OperatorTok{:}\NormalTok{ s }\KeywordTok{{-}\textgreater{}}\NormalTok{ a}
\FunctionTok{set }\OperatorTok{:}\NormalTok{ s }\KeywordTok{{-}\textgreater{}}\NormalTok{ b }\KeywordTok{{-}\textgreater{}}\NormalTok{ t}
\end{Highlighting}
\end{Shaded}

That is, a resource \texttt{r} with state \texttt{st}, arguments
\texttt{args}, updated value \texttt{nv}, and a feedback value
\texttt{fv}, is a lens:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set }\OperatorTok{:}\NormalTok{ (args, st) }\KeywordTok{{-}\textgreater{}}\NormalTok{ r}
\FunctionTok{get }\OperatorTok{:}\NormalTok{ (args, st) }\KeywordTok{{-}\textgreater{}}\NormalTok{ nv }\KeywordTok{{-}\textgreater{}}\NormalTok{ (fv, st)}
\end{Highlighting}
\end{Shaded}

The signature of this lens is our API and its implementation is the
implementation of our server. This guides us toward our first key
observation:

\begin{quote}
Every resource exposed by a server gives rise to a lens.
\end{quote}

\hypertarget{api-definitions-using-lenses}{%
\section{API definitions using
lenses}\label{api-definitions-using-lenses}}

This result provides us with a new way to define web servers
and their API: as the composition of lenses. A server is but a way to
\emph{view} and \emph{update} a resource. In the following
example, we define an API for a home server that manages lights in a
home.

% \NormalTok{thermostat }\OperatorTok{:} \DataTypeTok{Path}
% \NormalTok{thermostat }\KeywordTok{=} \StringTok{"therm"} \OperatorTok{/} \OtherTok{Resource} \DataTypeTok{Int}
% \NormalTok{boiler }\OperatorTok{:} \DataTypeTok{Path}
% \NormalTok{boiler }\KeywordTok{=} \StringTok{"boiler"} \OperatorTok{/} \OtherTok{Resource} \DataTypeTok{Bool}
\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{lights }\OperatorTok{:} \DataTypeTok{Path}
\FunctionTok{lights }\KeywordTok{=} \StringTok{"lights"} \OperatorTok{/} \OtherTok{Resource}\NormalTok{ (}\DataTypeTok{Double}\NormalTok{,}\DataTypeTok{Double}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This API features an endpoint \texttt{lights} which control the
intensity of two lights in the house using a \texttt{\DataTypeTok{Double}}
However the current API forces us to update \emph{both lights} in one go. We would
like to create endpoints like \texttt{lights/kitchen} and \texttt{lights/bedroom} to change the
intensity of each light. For this we are going to compose our
\texttt{lights} resource with two lenses, one for each element of the
pair:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{kitchen }\KeywordTok{=}\NormalTok{ lights }\OperatorTok{\textasciitilde{}/} \StringTok{"kitchen"} \OperatorTok{/} \OtherTok{Lens}\NormalTok{ lensFst}
\FunctionTok{bedroom }\KeywordTok{=}\NormalTok{ lights }\OperatorTok{\textasciitilde{}/} \StringTok{"bedroom"} \OperatorTok{/} \OtherTok{Lens}\NormalTok{ lensSnd}
\end{Highlighting}
\end{Shaded}

Where \texttt{lensFst} and \texttt{lensSnd} are the lenses accessing the
first and second element of a pair. The \texttt{\OperatorTok{\textasciitilde{}/}} operator
replaces the \texttt{\OtherTok{Ends}} constructor by a new path using the given
path component as string (here \texttt{kitchen} and \texttt{bedroom}) and matching lens for
the previous return type.

We observe that those endpoints do not
require any additional implementation: Their implementation is given by
their lenses. This leads to our second key statement:

\begin{quote}
A server consists of a resource type, paired with paths and lenses focusing on different parts of that resource
\end{quote}

This statement is a bit less powerful than the previous one because each
lens also needs to be augmented with a url path that uniquely
identifies the resource as an endpoint. However, we now have a strategy to extend, refactor, and implement
any endpoint without writing any more code than necessary. It is enough to
describe our main \emph{resource} and to provide lenses that focus on specific
parts of it.

\section{Conclusion}

Compared to Swagger our approach remains entirely \emph{inside} the language, ensuring
that the code and its API do not get out of sync. Compared to Servant, having access
to first-class types enables various forms of meta-programming. For example one can:
\begin{itemize}
  \item Manipulate endpoints as values, for example operating on each path component, or generating
    an endpoint from a string.
  \item Manipulate APIs at runtime and serve them using the implementation of their lenses.
  \item Enforce API properties, for example statically checking that the server has no overlapping
    endpoints.
\end{itemize}

Some of those advancements have been implemented in the \emph{Servis}\cite{servis} project.
Servis' primary goal was to fix some of the limitations of Servant due to Haskell not featuring
dependent types. Our library improves on Servis by exposing the relationship between endpoints and
lenses.

Our library does not say anything about concurrency, two unrelated endpoints should be accessible
concurrently, but because of our implementation of state, we cannot serve multiple clients at the
same time.
What's more, servers do not rely on their state being stored in memory, but use databases to store
and fetch data. An obvious improvement would be to explain the relationship between the server's API
and the database(s) it communicates with. Finally, error handling is an important aspect of API design
and our lens abstraction does not say anything about it. It would be useful to talk about those future
developments with the community and explore the place of dependent types in
backend software engineering.

\newpage
\bibliographystyle{ACM-Reference-Format}
\bibliography{custom}

\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'.
