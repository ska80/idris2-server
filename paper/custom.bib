 @masterthesis{servis, title={Servis: A dependently typed DSL for web APIs}, url={https://github.com/arianvp/servis}, school={University of Utrecht}, author={Arian van Putten}, year={2016}, month={Aug} }
 @article{idris1, title={Idris, a general-purpose dependently typed programming language: Design and implementation}, volume={23}, ISSN={0956-7968, 1469-7653}, DOI={10.1017/S095679681300018X}, abstractNote={Many components of a dependently typed programming language are by now well understood, for example, the underlying type theory, type checking, unification and evaluation. How to combine these components into a realistic and usable high-level language is, however, folklore, discovered anew by successive language implementors. In this paper, I describe the implementation of Idris, a new dependently typed functional programming language. Idris is intended to be a general-purpose programming language and as such provides high-level concepts such as implicit syntax, type classes and do notation. I describe the high-level language and the underlying type theory, and present a tactic-based method for elaborating concrete high-level syntax with implicit arguments and type classes into a fully explicit type theory. Furthermore, I show how this method facilitates the implementation of new high-level language constructs.}, number={5}, journal={Journal of Functional Programming}, author={Brady, Edwin}, year={2013}, month={Sep}, pages={552–593} }
 @article{idris2, title={Idris 2: Quantitative Type Theory in Practice}, url={http://arxiv.org/abs/2104.00480}, abstractNote={Dependent types allow us to express precisely what a function is intended to do. Recent work on Quantitative Type Theory (QTT) extends dependent type systems with linearity, also allowing precision in expressing when a function can run. This is promising, because it suggests the ability to design and reason about resource usage protocols, such as we might find in distributed and concurrent programming, where the state of a communication channel changes throughout program execution. As yet, however, there has not been a full-scale programming language with which to experiment with these ideas. Idris 2 is a new version of the dependently typed language Idris, with a new core language based on QTT, supporting linear and dependent types. In this paper, we introduce Idris 2, and describe how QTT has influenced its design. We give examples of the benefits of QTT in practice including: expressing which data is erased at run time, at the type level; and, resource tracking in the type system leading to type-safe concurrent programming with session types.}, note={arXiv: 2104.00480}, journal={arXiv:2104.00480 [cs]}, author={Brady, Edwin}, year={2021}, month={Apr} }
 @book{kmettlens, title={Lens library}, url={https://hackage.haskell.org/package/lens-4.15.1}, author={Edward A. Kmett} }
 @book{http, title={Hypertext Transfer Protocol -- HTTP/1.1}, url={https://www.rfc-editor.org/info/rfc2616}, DOI={10.17487/rfc2616}, number={RFC2616}, institution={RFC Editor}, author={Fielding, R. and Gettys, J. and Mogul, J. and Frystyk, H. and Masinter, L. and Leach, P. and Berners-Lee, T.}, year={1999}, month={Jun}, pages={RFC2616} }
 @inproceedings{servant, place={Vancouver BC Canada}, title={Type-level web APIs with Servant: an exercise in domain-specific generic programming}, ISBN={978-1-4503-3810-3}, url={https://dl.acm.org/doi/10.1145/2808098.2808099}, DOI={10.1145/2808098.2808099}, booktitle={Proceedings of the 11th ACM SIGPLAN Workshop on Generic Programming}, publisher={ACM}, author={Mestanogullari, Alp and Hahn, Sönke and Arni, Julian K. and Löh, Andres}, year={2015}, month={Aug}, pages={1–12} }
 @article{profunctors, title={Profunctor Optics: Modular Data Accessors}, volume={1}, ISSN={2473-7321}, DOI={10.22152/programming-journal.org/2017/1/7}, abstractNote={CONTEXT: Data accessors allow one to read and write components of a data structure, such as the fields of a record, the variants of a union, or the elements of a container. These data accessors are collectively known as optics; they are fundamental to programs that manipulate complex data. INQUIRY: Individual data accessors for simple data structures are easy to write, for example as pairs of “getter” and “setter” methods. However, it is not obvious how to combine data accessors, in such a way that data accessors for a compound data structure are composed out of smaller data accessors for the parts of that structure. Generally, one has to write a sequence of statements or declarations that navigate step by step through the data structure, accessing one level at a time - which is to say, data accessors are traditionally not first-class citizens, combinable in their own right. APPROACH: We present a framework for modular data access, in which individual data accessors for simple data structures may be freely combined to obtain more complex data accessors for compound data structures. Data accessors become first-class citizens. The framework is based around the notion of profunctors, a flexible generalization of functions. KNOWLEDGE: The language features required are higher-order functions (“lambdas” or “closures”), parametrized types (“generics” or “abstract types”), and some mechanism for separating interfaces from implementations (“abstract classes” or “modules”). We use Haskell as a vehicle in which to present our constructions, but languages such as Java, C#, or Scala that provide the necessary features should work just as well. GROUNDING: We provide implementations of all our constructions, in the form of a literate program: the manuscript file for the paper is also the source code for the program, and the extracted code is available separately for evaluation. We also prove the essential properties demonstrating that our profunctor-based representations are precisely equivalent to the more familiar concrete representations. IMPORTANCE: Our results should pave the way to simpler ways of writing programs that access the components of compound data structures.}, note={arXiv: 1703.10857}, number={2}, journal={The Art, Science, and Engineering of Programming}, author={Pickering, Matthew and Gibbons, Jeremy and Wu, Nicolas}, year={2017}, month={Apr}, pages={7} }
 @book{swagger, url={https://swagger.io}, publisher={SmartBear} }
 @book{typedefs, url={https://github.com/typedefs/typedefs}, publisher={Statebox} }
